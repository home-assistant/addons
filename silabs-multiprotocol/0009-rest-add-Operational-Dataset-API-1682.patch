From ced6eebdb5c73617f81dfcf3369e9a62c3fafaf1 Mon Sep 17 00:00:00 2001
Message-Id: <ced6eebdb5c73617f81dfcf3369e9a62c3fafaf1.1684999160.git.stefan@agner.ch>
In-Reply-To: <c2dc2a9940d1f9809403d4dfb28e1f942ef90bab.1684999160.git.stefan@agner.ch>
References: <c2dc2a9940d1f9809403d4dfb28e1f942ef90bab.1684999160.git.stefan@agner.ch>
From: Stefan Agner <stefan@agner.ch>
Date: Wed, 10 May 2023 03:22:31 +0200
Subject: [PATCH] [rest] add Operational Dataset API (#1682)

This commit extends the REST API to support reading and writing Active
and Pending Operational Datasets.

It adds the following endpoints and methods:

* /node/dataset/active [`GET`, `OPTIONS`, `POST`, `PUT`]
* /node/dataset/pending [`GET`, `OPTIONS`, `POST`, `PUT`]

The `GET` method returns current datasets, `POST` allows to create a
new dataset (with defaults as initialized by the OpenThread
implementation just like `ot-ctl dataset init new`). Any fields
provided with `POST` will overwrite the defaults, hence a call like

```
curl -X POST http://localhost:8081/node/dataset/pending -d '{ "Delay": 30000, "ActiveTimestamp": 10 }'
```

Is equivalent to:

```
ot-ctl dataset init new
ot-ctl dataset delay 30000
ot-ctl dataset activetimestamp 10
ot-ctl dataset commit pending
```

`PUT` requests do not initialize a new dataset (which makes the call
idempotent as defined in HTTP). `PUT` simply loads the current dataset
and updates it with the new values provided by the JSON body. When
using the TLV format PUT is a simple write to the active/pending
dataset.

Datasets can be read and written using a straight forward JSON format
or alternatively using the Dataset TLV format. This is implemented in
a RESTful manor by using the same endpoints but `Content-Type` to
distinguish the two data formats. The `application/json` type is used
for JSON and `plain/text` for Dataset TLV format.

The API is documented by a OpenAPI Specification (Swagger). The YAML
description file is stored at `src/rest/openapi.yaml`. Swagger UI
allows to test all the variants described above as well. To start
Swagger UI locally the following command can be used:

```
docker run -p 8082:8080 -e SWAGGER_JSON=/openapi.yaml -v $(pwd)/src/rest/openapi.yaml:/openapi.yaml swaggerapi/swagger-ui
```

The following things are open/tbd at this point:

- No method to change state of the OTBR (probably best done in a separate PR)
- Automatic/implicit `ActiveTimestamp` support (or should this be left to the client)
- Generate Swagger UI API in GitHub actions/deploy GitHub pages?
- Additional testing/unit tests?

The commit also removes the `/node/active-dataset-tlvs` endpoint as it
is obsolete with this much more capable endpoints.

(cherry picked from commit 21c5b675d883ba5e18415ba3d5dbb7ffc539829b)
---
 src/rest/json.cpp     | 427 ++++++++++++++++++++++++++++++++++++++++++
 src/rest/json.hpp     |  47 +++++
 src/rest/openapi.yaml | 423 +++++++++++++++++++++++++++++++++++++++++
 src/rest/parser.cpp   |  28 ++-
 src/rest/request.cpp  |  18 ++
 src/rest/request.hpp  |  40 +++-
 src/rest/resource.cpp | 178 +++++++++++++++---
 src/rest/resource.hpp |  20 +-
 src/rest/response.cpp |  10 +-
 src/rest/response.hpp |   8 +
 src/rest/types.hpp    |  10 +-
 src/utils/hex.cpp     |  40 ++--
 src/utils/hex.hpp     |  40 ++++
 13 files changed, 1230 insertions(+), 59 deletions(-)
 create mode 100644 src/rest/openapi.yaml

diff --git a/src/rest/json.cpp b/src/rest/json.cpp
index 3a6c9aa08f..61c0be2046 100644
--- a/src/rest/json.cpp
+++ b/src/rest/json.cpp
@@ -27,6 +27,7 @@
  */
 
 #include "rest/json.hpp"
+#include <sstream>
 
 #include "common/code_utils.hpp"
 #include "common/types.hpp"
@@ -114,6 +115,131 @@ static cJSON *IpAddr2Json(const otIp6Address &aAddress)
     return cJSON_CreateString(addr.ToString().c_str());
 }
 
+static cJSON *IpPrefix2Json(const otIp6NetworkPrefix &aAddress)
+{
+    std::stringstream ss;
+    otIp6Address      address = {};
+
+    address.mFields.mComponents.mNetworkPrefix = aAddress;
+    Ip6Address addr(address.mFields.m8);
+
+    ss << addr.ToString() << "/" << OT_IP6_PREFIX_BITSIZE;
+
+    return cJSON_CreateString(ss.str().c_str());
+}
+
+otbrError Json2IpPrefix(const cJSON *aJson, otIp6NetworkPrefix &aIpPrefix)
+{
+    otbrError          error = OTBR_ERROR_NONE;
+    std::istringstream ipPrefixStr(std::string(aJson->valuestring));
+    std::string        tmp;
+    Ip6Address         addr;
+
+    VerifyOrExit(std::getline(ipPrefixStr, tmp, '/'), error = OTBR_ERROR_INVALID_ARGS);
+    VerifyOrExit((error = addr.FromString(tmp.c_str(), addr)) == OTBR_ERROR_NONE);
+
+    memcpy(aIpPrefix.m8, addr.m8, OT_IP6_PREFIX_SIZE);
+exit:
+    return error;
+}
+
+static cJSON *Timestamp2Json(const otTimestamp &aTimestamp)
+{
+    cJSON *timestamp = cJSON_CreateObject();
+
+    cJSON_AddItemToObject(timestamp, "Seconds", cJSON_CreateNumber(aTimestamp.mSeconds));
+    cJSON_AddItemToObject(timestamp, "Ticks", cJSON_CreateNumber(aTimestamp.mTicks));
+    cJSON_AddItemToObject(timestamp, "Authoritative", cJSON_CreateBool(aTimestamp.mAuthoritative));
+
+    return timestamp;
+}
+
+bool Json2Timestamp(const cJSON *jsonTimestamp, otTimestamp &aTimestamp)
+{
+    cJSON *value;
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonTimestamp, "Seconds");
+    if (cJSON_IsNumber(value))
+    {
+        aTimestamp.mSeconds = static_cast<uint64_t>(value->valuedouble);
+    }
+    else if (value != nullptr)
+    {
+        return false;
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonTimestamp, "Ticks");
+    if (cJSON_IsNumber(value))
+    {
+        aTimestamp.mTicks = static_cast<uint16_t>(value->valueint);
+    }
+    else if (value != nullptr)
+    {
+        return false;
+    }
+
+    value                     = cJSON_GetObjectItemCaseSensitive(jsonTimestamp, "Authoritative");
+    aTimestamp.mAuthoritative = cJSON_IsTrue(value);
+
+    return true;
+}
+
+static cJSON *SecurityPolicy2Json(const otSecurityPolicy &aSecurityPolicy)
+{
+    cJSON *securityPolicy = cJSON_CreateObject();
+
+    cJSON_AddItemToObject(securityPolicy, "RotationTime", cJSON_CreateNumber(aSecurityPolicy.mRotationTime));
+    cJSON_AddItemToObject(securityPolicy, "ObtainNetworkKey",
+                          cJSON_CreateBool(aSecurityPolicy.mObtainNetworkKeyEnabled));
+    cJSON_AddItemToObject(securityPolicy, "NativeCommissioning",
+                          cJSON_CreateBool(aSecurityPolicy.mNativeCommissioningEnabled));
+    cJSON_AddItemToObject(securityPolicy, "Routers", cJSON_CreateBool(aSecurityPolicy.mRoutersEnabled));
+    cJSON_AddItemToObject(securityPolicy, "ExternalCommissioning",
+                          cJSON_CreateBool(aSecurityPolicy.mExternalCommissioningEnabled));
+    cJSON_AddItemToObject(securityPolicy, "CommercialCommissioning",
+                          cJSON_CreateBool(aSecurityPolicy.mCommercialCommissioningEnabled));
+    cJSON_AddItemToObject(securityPolicy, "AutonomousEnrollment",
+                          cJSON_CreateBool(aSecurityPolicy.mAutonomousEnrollmentEnabled));
+    cJSON_AddItemToObject(securityPolicy, "NetworkKeyProvisioning",
+                          cJSON_CreateBool(aSecurityPolicy.mNetworkKeyProvisioningEnabled));
+    cJSON_AddItemToObject(securityPolicy, "TobleLink", cJSON_CreateBool(aSecurityPolicy.mTobleLinkEnabled));
+    cJSON_AddItemToObject(securityPolicy, "NonCcmRouters", cJSON_CreateBool(aSecurityPolicy.mNonCcmRoutersEnabled));
+
+    return securityPolicy;
+}
+
+bool Json2SecurityPolicy(const cJSON *jsonSecurityPolicy, otSecurityPolicy &aSecurityPolicy)
+{
+    cJSON *value;
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "RotationTime");
+    if (cJSON_IsNumber(value))
+    {
+        aSecurityPolicy.mRotationTime = static_cast<uint16_t>(value->valueint);
+    }
+
+    value                                    = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "ObtainNetworkKey");
+    aSecurityPolicy.mObtainNetworkKeyEnabled = cJSON_IsTrue(value);
+    value = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "NativeCommissioning");
+    aSecurityPolicy.mNativeCommissioningEnabled = cJSON_IsTrue(value);
+    value                                       = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "Routers");
+    aSecurityPolicy.mRoutersEnabled             = cJSON_IsTrue(value);
+    value = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "ExternalCommissioning");
+    aSecurityPolicy.mExternalCommissioningEnabled = cJSON_IsTrue(value);
+    value = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "CommercialCommissioning");
+    aSecurityPolicy.mCommercialCommissioningEnabled = cJSON_IsTrue(value);
+    value = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "AutonomousEnrollment");
+    aSecurityPolicy.mAutonomousEnrollmentEnabled = cJSON_IsTrue(value);
+    value = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "NetworkKeyProvisioning");
+    aSecurityPolicy.mNetworkKeyProvisioningEnabled = cJSON_IsTrue(value);
+    value                                          = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "TobleLink");
+    aSecurityPolicy.mTobleLinkEnabled              = cJSON_IsTrue(value);
+    value                                 = cJSON_GetObjectItemCaseSensitive(jsonSecurityPolicy, "NonCcmRouters");
+    aSecurityPolicy.mNonCcmRoutersEnabled = cJSON_IsTrue(value);
+
+    return true;
+}
+
 static cJSON *ChildTableEntry2Json(const otNetworkDiagChildEntry &aChildEntry)
 {
     cJSON *childEntry = cJSON_CreateObject();
@@ -482,6 +608,307 @@ std::string Error2JsonString(HttpStatusCode aErrorCode, std::string aErrorMessag
     return ret;
 }
 
+cJSON *ActiveDataset2Json(const otOperationalDataset &aActiveDataset)
+{
+    cJSON *node = cJSON_CreateObject();
+
+    if (aActiveDataset.mComponents.mIsActiveTimestampPresent)
+    {
+        cJSON_AddItemToObject(node, "ActiveTimestamp", Timestamp2Json(aActiveDataset.mActiveTimestamp));
+    }
+    if (aActiveDataset.mComponents.mIsNetworkKeyPresent)
+    {
+        cJSON_AddItemToObject(node, "NetworkKey", Bytes2HexJson(aActiveDataset.mNetworkKey.m8, OT_NETWORK_KEY_SIZE));
+    }
+    if (aActiveDataset.mComponents.mIsNetworkNamePresent)
+    {
+        cJSON_AddItemToObject(node, "NetworkName", cJSON_CreateString(aActiveDataset.mNetworkName.m8));
+    }
+    if (aActiveDataset.mComponents.mIsExtendedPanIdPresent)
+    {
+        cJSON_AddItemToObject(node, "ExtPanId", Bytes2HexJson(aActiveDataset.mExtendedPanId.m8, OT_EXT_PAN_ID_SIZE));
+    }
+    if (aActiveDataset.mComponents.mIsMeshLocalPrefixPresent)
+    {
+        cJSON_AddItemToObject(node, "MeshLocalPrefix", IpPrefix2Json(aActiveDataset.mMeshLocalPrefix));
+    }
+    if (aActiveDataset.mComponents.mIsPanIdPresent)
+    {
+        cJSON_AddItemToObject(node, "PanId", cJSON_CreateNumber(aActiveDataset.mPanId));
+    }
+    if (aActiveDataset.mComponents.mIsChannelPresent)
+    {
+        cJSON_AddItemToObject(node, "Channel", cJSON_CreateNumber(aActiveDataset.mChannel));
+    }
+    if (aActiveDataset.mComponents.mIsPskcPresent)
+    {
+        cJSON_AddItemToObject(node, "PSKc", Bytes2HexJson(aActiveDataset.mPskc.m8, OT_PSKC_MAX_SIZE));
+    }
+    if (aActiveDataset.mComponents.mIsSecurityPolicyPresent)
+    {
+        cJSON_AddItemToObject(node, "SecurityPolicy", SecurityPolicy2Json(aActiveDataset.mSecurityPolicy));
+    }
+    if (aActiveDataset.mComponents.mIsChannelMaskPresent)
+    {
+        cJSON_AddItemToObject(node, "ChannelMask", cJSON_CreateNumber(aActiveDataset.mChannelMask));
+    }
+
+    return node;
+}
+
+std::string ActiveDataset2JsonString(const otOperationalDataset &aActiveDataset)
+{
+    cJSON      *node;
+    std::string ret;
+
+    node = ActiveDataset2Json(aActiveDataset);
+    ret  = Json2String(node);
+    cJSON_Delete(node);
+
+    return ret;
+}
+
+std::string PendingDataset2JsonString(const otOperationalDataset &aPendingDataset)
+{
+    cJSON      *nodeActiveDataset;
+    cJSON      *node = cJSON_CreateObject();
+    std::string ret;
+
+    nodeActiveDataset = ActiveDataset2Json(aPendingDataset);
+    cJSON_AddItemToObject(node, "ActiveDataset", nodeActiveDataset);
+    if (aPendingDataset.mComponents.mIsPendingTimestampPresent)
+    {
+        cJSON_AddItemToObject(node, "PendingTimestamp", Timestamp2Json(aPendingDataset.mPendingTimestamp));
+    }
+    if (aPendingDataset.mComponents.mIsDelayPresent)
+    {
+        cJSON_AddItemToObject(node, "Delay", cJSON_CreateNumber(aPendingDataset.mDelay));
+    }
+
+    ret = Json2String(node);
+    cJSON_Delete(node);
+
+    return ret;
+}
+
+bool JsonActiveDataset2Dataset(const cJSON *jsonActiveDataset, otOperationalDataset &aDataset)
+{
+    cJSON      *value;
+    otTimestamp timestamp;
+    bool        ret = true;
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "ActiveTimestamp");
+    if (cJSON_IsObject(value))
+    {
+        VerifyOrExit(Json2Timestamp(value, timestamp), ret = false);
+        aDataset.mActiveTimestamp                      = timestamp;
+        aDataset.mComponents.mIsActiveTimestampPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsActiveTimestampPresent = false;
+    }
+    else if (value != nullptr)
+    {
+        ExitNow(ret = false);
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "NetworkKey");
+    if (cJSON_IsString(value))
+    {
+        VerifyOrExit(value->valuestring != nullptr, ret = false);
+        VerifyOrExit(Hex2BytesJsonString(std::string(value->valuestring), aDataset.mNetworkKey.m8,
+                                         OT_NETWORK_KEY_SIZE) == OT_NETWORK_KEY_SIZE,
+                     ret = false);
+        aDataset.mComponents.mIsNetworkKeyPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsNetworkKeyPresent = false;
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "NetworkName");
+    if (cJSON_IsString(value))
+    {
+        VerifyOrExit(value->valuestring != nullptr, ret = false);
+        VerifyOrExit(strlen(value->valuestring) <= OT_NETWORK_NAME_MAX_SIZE, ret = false);
+        strncpy(aDataset.mNetworkName.m8, value->valuestring, OT_NETWORK_NAME_MAX_SIZE);
+        aDataset.mComponents.mIsNetworkNamePresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsNetworkNamePresent = false;
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "ExtPanId");
+    if (cJSON_IsString(value))
+    {
+        VerifyOrExit(value->valuestring != nullptr, ret = false);
+        VerifyOrExit(Hex2BytesJsonString(std::string(value->valuestring), aDataset.mExtendedPanId.m8,
+                                         OT_EXT_PAN_ID_SIZE) == OT_EXT_PAN_ID_SIZE,
+                     ret = false);
+        aDataset.mComponents.mIsExtendedPanIdPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsExtendedPanIdPresent = false;
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "MeshLocalPrefix");
+    if (cJSON_IsString(value))
+    {
+        VerifyOrExit(value->valuestring != nullptr, ret = false);
+        VerifyOrExit(Json2IpPrefix(value, aDataset.mMeshLocalPrefix) == OTBR_ERROR_NONE, ret = false);
+        aDataset.mComponents.mIsMeshLocalPrefixPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsMeshLocalPrefixPresent = false;
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "PanId");
+    if (cJSON_IsNumber(value))
+    {
+        aDataset.mPanId                      = static_cast<otPanId>(value->valueint);
+        aDataset.mComponents.mIsPanIdPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsPanIdPresent = false;
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "Channel");
+    if (cJSON_IsNumber(value))
+    {
+        aDataset.mChannel                      = static_cast<uint16_t>(value->valueint);
+        aDataset.mComponents.mIsChannelPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsChannelPresent = false;
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "PSKc");
+    if (cJSON_IsString(value))
+    {
+        VerifyOrExit(value->valuestring != nullptr, ret = false);
+        VerifyOrExit(Hex2BytesJsonString(std::string(value->valuestring), aDataset.mPskc.m8, OT_PSKC_MAX_SIZE) ==
+                         OT_PSKC_MAX_SIZE,
+                     ret = false);
+        aDataset.mComponents.mIsPskcPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsPskcPresent = false;
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "SecurityPolicy");
+    if (cJSON_IsObject(value))
+    {
+        VerifyOrExit(Json2SecurityPolicy(value, aDataset.mSecurityPolicy), ret = false);
+        aDataset.mComponents.mIsSecurityPolicyPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsSecurityPolicyPresent = false;
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonActiveDataset, "ChannelMask");
+    if (cJSON_IsNumber(value))
+    {
+        aDataset.mChannelMask                      = value->valueint;
+        aDataset.mComponents.mIsChannelMaskPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsChannelMaskPresent = false;
+    }
+
+exit:
+    return ret;
+}
+
+bool JsonActiveDatasetString2Dataset(const std::string &aJsonActiveDataset, otOperationalDataset &aDataset)
+{
+    cJSON *jsonActiveDataset;
+    bool   ret = true;
+
+    VerifyOrExit((jsonActiveDataset = cJSON_Parse(aJsonActiveDataset.c_str())) != nullptr, ret = false);
+    VerifyOrExit(cJSON_IsObject(jsonActiveDataset), ret = false);
+
+    ret = JsonActiveDataset2Dataset(jsonActiveDataset, aDataset);
+
+exit:
+    cJSON_Delete(jsonActiveDataset);
+
+    return ret;
+}
+
+bool JsonPendingDatasetString2Dataset(const std::string &aJsonPendingDataset, otOperationalDataset &aDataset)
+{
+    cJSON      *value;
+    cJSON      *jsonDataset;
+    otTimestamp timestamp;
+    bool        ret = true;
+
+    VerifyOrExit((jsonDataset = cJSON_Parse(aJsonPendingDataset.c_str())) != nullptr, ret = false);
+    VerifyOrExit(cJSON_IsObject(jsonDataset), ret = false);
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonDataset, "ActiveDataset");
+    if (cJSON_IsObject(value))
+    {
+        VerifyOrExit(JsonActiveDataset2Dataset(value, aDataset), ret = false);
+    }
+    else if (cJSON_IsString(value))
+    {
+        otOperationalDatasetTlvs datasetTlvs;
+        int                      len;
+
+        len =
+            Hex2BytesJsonString(std::string(value->valuestring), datasetTlvs.mTlvs, OT_OPERATIONAL_DATASET_MAX_LENGTH);
+        VerifyOrExit(len > 0, ret = false);
+        datasetTlvs.mLength = len;
+
+        VerifyOrExit(otDatasetParseTlvs(&datasetTlvs, &aDataset) == OT_ERROR_NONE, ret = false);
+    }
+    else
+    {
+        ExitNow(ret = false);
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonDataset, "PendingTimestamp");
+    if (cJSON_IsObject(value))
+    {
+        VerifyOrExit(Json2Timestamp(value, timestamp), ret = false);
+        aDataset.mPendingTimestamp                      = timestamp;
+        aDataset.mComponents.mIsPendingTimestampPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsPendingTimestampPresent = false;
+    }
+    else if (value != nullptr)
+    {
+        ExitNow(ret = false);
+    }
+
+    value = cJSON_GetObjectItemCaseSensitive(jsonDataset, "Delay");
+    if (cJSON_IsNumber(value))
+    {
+        aDataset.mDelay                      = value->valueint;
+        aDataset.mComponents.mIsDelayPresent = true;
+    }
+    else if (cJSON_IsNull(value))
+    {
+        aDataset.mComponents.mIsDelayPresent = false;
+    }
+
+exit:
+    cJSON_Delete(jsonDataset);
+
+    return ret;
+}
+
 } // namespace Json
 } // namespace rest
 } // namespace otbr
diff --git a/src/rest/json.hpp b/src/rest/json.hpp
index e9fd178201..29153d5149 100644
--- a/src/rest/json.hpp
+++ b/src/rest/json.hpp
@@ -34,6 +34,7 @@
 #ifndef OTBR_REST_JSON_HPP_
 #define OTBR_REST_JSON_HPP_
 
+#include "openthread/dataset.h"
 #include "openthread/link.h"
 #include "openthread/thread_ftd.h"
 
@@ -213,6 +214,52 @@ std::string ChildTableEntry2JsonString(const otNetworkDiagChildEntry &aChildEntr
  */
 std::string Error2JsonString(HttpStatusCode aErrorCode, std::string aErrorMessage);
 
+/**
+ * This method formats a Json object from an active dataset.
+ *
+ * @param[in] aDataset  A dataset struct.
+ *
+ * @returns A string of serialized Json object.
+ *
+ */
+std::string ActiveDataset2JsonString(const otOperationalDataset &aDataset);
+
+/**
+ * This method formats a Json object from a pending dataset.
+ *
+ * @param[in] aDataset  A dataset struct.
+ *
+ * @returns A string of serialized Json object.
+ *
+ */
+std::string PendingDataset2JsonString(const otOperationalDataset &aPendingDataset);
+
+/**
+ * This method parses a Json string and fills the provided dataset. Fields
+ * set to null are cleared (set to not present). Non-present fields are left
+ * as is.
+ *
+ * @param[in] aJsonActiveDataset  The Json string to be parsed.
+ * @param[in] aDataset            The dataset struct to be filled.
+ *
+ * @returns If the Json string has been successfully parsed.
+ *
+ */
+bool JsonActiveDatasetString2Dataset(const std::string &aJsonActiveDataset, otOperationalDataset &aDataset);
+
+/**
+ * This method parses a Json string and fills the provided dataset. Fields
+ * set to null are cleared (set to not present). Non-present fields are left
+ * as is.
+ *
+ * @param[in] aJsonActiveDataset  The Json string to be parsed.
+ * @param[in] aDataset            The dataset struct to be filled.
+ *
+ * @returns If the Json string has been successfully parsed.
+ *
+ */
+bool JsonPendingDatasetString2Dataset(const std::string &aJsonPendingDataset, otOperationalDataset &aDataset);
+
 }; // namespace Json
 
 } // namespace rest
diff --git a/src/rest/openapi.yaml b/src/rest/openapi.yaml
new file mode 100644
index 0000000000..d2bb2f0026
--- /dev/null
+++ b/src/rest/openapi.yaml
@@ -0,0 +1,423 @@
+openapi: 3.0.3
+info:
+  title: Swagger OpenThread REST API
+  description: |-
+    This describes the OpenThread Border Router REST API. The API is provided by the otbr-agent, if the cmake flag `OTBR_REST=ON` is set. By default
+    the REST API listens on any address on port 8081.
+
+    Some useful links:
+    - [OpenThread Border Router repository](github.com/openthread/ot-br-posix/)
+  license:
+    name: BSD 3-Clause
+    url: https://github.com/openthread/ot-br-posix/blob/main/LICENSE
+  version: 0.3.0
+servers:
+  - url: http://localhost:8081
+tags:
+  - name: node
+    description: Thread parameters of this node.
+  - name: diagnostics
+    description: Thread network diagnostic.
+paths:
+  /diagnostics:
+    get:
+      tags:
+        - diagnostics
+      summary: Get Thread network diagnostics
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                type: object
+  /node:
+    get:
+      tags:
+        - node
+      summary: Get current active node parameters
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                type: object
+  /node/rloc:
+    get:
+      tags:
+        - node
+      summary: Routing Locator IPv6 address of this Thread node.
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                type: string
+                description: RLOC IPv6 address
+                example: "fda4:728e:4b39:bc4a:0:ff:fe00:1000"
+  /node/rloc16:
+    get:
+      tags:
+        - node
+      summary: Routing Locator Router and Child ID (RLOC16).
+      description: Last 16-bit of the Routing Locator IPv6 consisting of the Router ID and a Child ID.
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                type: number
+                description: RLOC16 address
+                example: 4096
+  /node/ext-address:
+    get:
+      tags:
+        - node
+      summary: IEEE 802.15.4 Extended Address (EUI-64).
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                type: string
+                description: 8-byte IEEE 802.15.4 Extended Address of this node as hex string.
+                example: "C21F906BE0352A4C"
+  /node/state:
+    get:
+      tags:
+        - node
+      summary: Get current Thread state.
+      description: |-
+        State describing the current Thread role of this Thread node.
+        - 0: disabled
+        - 1: detached
+        - 2: child
+        - 3: router
+        - 4: leader
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                type: number
+                description: Current state
+                example: 4
+  /node/network-name:
+    get:
+      tags:
+        - node
+      summary: Thread network name this node is part of.
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                type: string
+                description: Thread network name.
+                example: "OpenThread-e445"
+  /node/leader-data:
+    get:
+      tags:
+        - node
+      summary: Gets the network's leader data.
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                $ref: "#/components/schemas/LeaderData"
+  /node/ext-panid:
+    get:
+      tags:
+        - node
+      summary: Extended PAN ID.
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                type: string
+                description: 8-byte extended PAN ID as hex string.
+                example: "3CAB144450CF407E"
+  /node/num-of-router:
+    get:
+      tags:
+        - node
+      summary: Get number of router devices
+      responses:
+        "200":
+          description: Successful operation
+          content:
+            application/json:
+              schema:
+                type: number
+                description: Number of routers
+                example: 1
+  /node/dataset/active:
+    get:
+      tags:
+        - node
+      summary: Get current active operational dataset
+      responses:
+        "200":
+          description: Returns currently active operational dataset
+          content:
+            application/json:
+              schema:
+                $ref: "#/components/schemas/Dataset"
+            text/plain:
+              schema:
+                $ref: "#/components/schemas/DatasetTlv"
+        "204":
+          description: No active operational dataset
+    put:
+      tags:
+        - node
+      summary: Creates or updates the active operational dataset
+      description: |-
+        Creates or updates the the active operational dataset on the current node. Only allowed if the Thread node
+        is inactive. If the Thread node is active, a pending dataset should be used to update the current active
+        operational dataset.
+      requestBody:
+        description: |-
+          Operational dataset that will be stored as active operational dataset. Supports request body Content-Type
+          `text/plain` (dataset in TLV format as hex string) or `application/json` (dataset in JSON format). In both
+          cases keys which are not set will be initialized with defaults.
+        content:
+          application/json:
+            schema:
+              $ref: "#/components/schemas/ActiveDataset"
+          plain/text:
+            schema:
+              $ref: "#/components/schemas/DatasetTlv"
+      responses:
+        "200":
+          description: Successfully updated the active operational dataset.
+        "201":
+          description: Successfully created the active operational dataset.
+        "400":
+          description: Invalid request body.
+        "409":
+          description: Writing active operational dataset rejected because Thread network is active.
+  /node/dataset/pending:
+    get:
+      tags:
+        - node
+      summary: Get current pending operational dataset
+      responses:
+        "200":
+          description: Returns currently pending operational dataset
+          content:
+            application/json:
+              schema:
+                $ref: "#/components/schemas/PendingDataset"
+            text/plain:
+              schema:
+                $ref: "#/components/schemas/DatasetTlv"
+        "204":
+          description: No pending operational dataset
+    put:
+      tags:
+        - node
+      summary: Creates or updates the pending operational dataset
+      description: |-
+        Creates or updates the the pending operational dataset on the current node. Delay needs to be set to let
+        the pending dataset apply as active dataset in the near future.
+      requestBody:
+        description: |-
+          Operational dataset that will be stored as pending operational dataset. Supports request body Content-Type
+          `text/plain` (dataset in TLV format as hex string) or `application/json` (dataset in JSON format). In both
+          cases keys which are not set will be initialized with defaults.
+        content:
+          application/json:
+            schema:
+              $ref: "#/components/schemas/PendingDataset"
+          text/plain:
+            schema:
+              $ref: "#/components/schemas/DatasetTlv"
+      responses:
+        "200":
+          description: Successfully updated the pending operational dataset.
+        "201":
+          description: Successfully created the pending operational dataset.
+        "400":
+          description: Invalid request body.
+components:
+  schemas:
+    LeaderData:
+      type: object
+      properties:
+        PartitionId:
+          type: number
+          format: uint32
+          description: Partition ID
+          example: 1230046604
+        Weighting:
+          type: number
+          format: uint8
+          description: Leader Weight
+          example: 64
+        DataVersion:
+          type: number
+          description: Full network data version
+          example: 244
+        StableDataVersion:
+          type: number
+          format: uint8
+          description: Stable Network Data Version
+          example: 186
+        LeaderRouterId:
+          type: number
+          format: uint8
+          description: Leader Router ID
+          example: 4
+    ActiveDataset:
+      type: object
+      properties:
+        ActiveTimestamp:
+          $ref: "#/components/schemas/Timestamp"
+        NetworkKey:
+          type: string
+          description: Network key, 16 bytes long, formatted as a hexadecimal string
+          example: 08277229F21FB7342D705D3CEFDC042A
+          default: random
+        NetworkName:
+          type: string
+          description: Network name, 16 bytes long
+          example: OpenThread-e445
+          default: OpenThread-<PanId>
+        ExtPanId:
+          type: string
+          description: Extended PAN ID, 8 bytes long, formatted as a hexadecimal string
+          example: 996D3BEE320097A3
+          default: random
+        MeshLocalPrefix:
+          type: string
+          description: Mesh local IPv6 prefix
+          example: fd33:d3b9:89e3:72e4::/64
+          default: random
+        PanId:
+          type: integer
+          description: IEEE 802.15.4 PAN ID of the Thread network
+          format: uint16
+          example: 58437
+          default: random
+        Channel:
+          type: integer
+          description: IEEE 802.15.4 channel of the Thread network
+          format: uint16
+          example: 21
+          default: random
+        PSKc:
+          type: string
+          description: The pre-shared commissioner key
+          example: FD943ECA225A28979B991EFAC1218A72
+          default: random
+        SecurityPolicy:
+          $ref: "#/components/schemas/SecurityPolicy"
+        ChannelMask:
+          type: integer
+          description: Channel mask
+          format: uint32
+          example: 134215680
+          default: 134215680
+    PendingDataset:
+      type: object
+      properties:
+        ActiveDataset:
+          oneOf:
+            - $ref: "#/components/schemas/ActiveDataset"
+            - $ref: "#/components/schemas/DatasetTlv"
+        PendingTimestamp:
+          $ref: "#/components/schemas/Timestamp"
+        Delay:
+          type: integer
+          description: Delay timer in milliseconds
+          format: uint32
+          example: 30000
+          default: not set
+    SecurityPolicy:
+      type: object
+      properties:
+        RotationTime:
+          type: integer
+          description: Thread key rotation time in hours
+          format: uint16
+          example: 672
+          default: 672
+        ObtainNetworkKey:
+          type: boolean
+          description: Obtaining the Network Key for out-of-band commissioning is enabled
+          example: true
+          default: true
+        NativeCommissioning:
+          type: boolean
+          description: Native Commissioning using PSKc is allowed
+          example: true
+          default: true
+        Routers:
+          type: boolean
+          description: Thread 1.0/1.1.x Routers are enabled
+          example: true
+          default: true
+        ExternalCommissioning:
+          type: boolean
+          description: External Commissioner authentication is allowed
+          example: true
+          default: true
+        CommercialCommissioning:
+          type: boolean
+          description: Commercial Commissioning is enabled
+          example: false
+          default: false
+        AutonomousEnrollment:
+          type: boolean
+          description: Autonomous Enrollment is enabled
+          example: false
+          default: false
+        NetworkKeyProvisioning:
+          type: boolean
+          description: Network Key Provisioning is enabled
+          example: false
+          default: false
+        TobleLink:
+          type: boolean
+          description: ToBLE link is enabled
+          example: false
+          default: false
+        NonCcmRouters:
+          type: boolean
+          description: Non-CCM Routers enabled
+          example: false
+          default: false
+    Timestamp:
+      type: object
+      properties:
+        Seconds:
+          type: integer
+          description: Timestamp seconds
+          format: uint64
+          example: 10
+          default: 1
+        Ticks:
+          type: integer
+          description: Timestamp ticks
+          format: uint16
+          example: 0
+          default: 0
+        Authoritative:
+          type: boolean
+          example: false
+          default: false
+    DatasetTlv:
+      type: string
+      description: Operational dataset as hex-encoded TLVs.
+      example: 0E080000000000010000000300000F35060004001FFFE0020811111111222222220708FDAD70BFE5AA15DD051000112233445566778899AABBCCDDEEFF030E4F70656E54687265616444656D6F010212340410445F2B5CA6F2A93A55CE570A70EFEECB0C0402A0F7F8
diff --git a/src/rest/parser.cpp b/src/rest/parser.cpp
index 566f88cbb2..9401e4d0d5 100644
--- a/src/rest/parser.cpp
+++ b/src/rest/parser.cpp
@@ -87,6 +87,30 @@ static int OnHandlerData(http_parser *, const char *, size_t)
     return 0;
 }
 
+static int OnHeaderField(http_parser *parser, const char *at, size_t len)
+{
+    Request *request = reinterpret_cast<Request *>(parser->data);
+
+    if (len > 0)
+    {
+        request->SetNextHeaderField(at, len);
+    }
+
+    return 0;
+}
+
+static int OnHeaderData(http_parser *parser, const char *at, size_t len)
+{
+    Request *request = reinterpret_cast<Request *>(parser->data);
+
+    if (len > 0)
+    {
+        request->SetHeaderValue(at, len);
+    }
+
+    return 0;
+}
+
 Parser::Parser(Request *aRequest)
 {
     mParser.data = aRequest;
@@ -97,8 +121,8 @@ void Parser::Init(void)
     mSettings.on_message_begin    = OnMessageBegin;
     mSettings.on_url              = OnUrl;
     mSettings.on_status           = OnHandlerData;
-    mSettings.on_header_field     = OnHandlerData;
-    mSettings.on_header_value     = OnHandlerData;
+    mSettings.on_header_field     = OnHeaderField;
+    mSettings.on_header_value     = OnHeaderData;
     mSettings.on_body             = OnBody;
     mSettings.on_headers_complete = OnHeaderComplete;
     mSettings.on_message_complete = OnMessageComplete;
diff --git a/src/rest/request.cpp b/src/rest/request.cpp
index ac3dc300c3..50a84bed76 100644
--- a/src/rest/request.cpp
+++ b/src/rest/request.cpp
@@ -27,6 +27,7 @@
  */
 
 #include "rest/request.hpp"
+#include "utils/string_utils.hpp"
 
 namespace otbr {
 namespace rest {
@@ -56,6 +57,16 @@ void Request::SetMethod(int32_t aMethod)
     mMethod = aMethod;
 }
 
+void Request::SetNextHeaderField(const char *aString, size_t aLength)
+{
+    mNextHeaderField = StringUtils::ToLowercase(std::string(aString, aLength));
+}
+
+void Request::SetHeaderValue(const char *aString, size_t aLength)
+{
+    mHeaders[mNextHeaderField] = std::string(aString, aLength);
+}
+
 HttpMethod Request::GetMethod() const
 {
     return static_cast<HttpMethod>(mMethod);
@@ -87,6 +98,13 @@ exit:
     return url;
 }
 
+std::string Request::GetHeaderValue(const std::string aHeaderField) const
+{
+    auto it = mHeaders.find(StringUtils::ToLowercase(aHeaderField));
+
+    return (it == mHeaders.end()) ? "" : it->second;
+}
+
 void Request::SetReadComplete(void)
 {
     mComplete = true;
diff --git a/src/rest/request.hpp b/src/rest/request.hpp
index 63380f0080..5b73b06736 100644
--- a/src/rest/request.hpp
+++ b/src/rest/request.hpp
@@ -34,8 +34,8 @@
 #ifndef OTBR_REST_REQUEST_HPP_
 #define OTBR_REST_REQUEST_HPP_
 
+#include <map>
 #include <string>
-#include <vector>
 
 #include "common/code_utils.hpp"
 #include "rest/types.hpp"
@@ -90,6 +90,24 @@ public:
      */
     void SetMethod(int32_t aMethod);
 
+    /**
+     * This method sets the next header field of a request.
+     *
+     * @param[in] aString  A pointer points to body string.
+     * @param[in] aLength  Length of the body string
+     *
+     */
+    void SetNextHeaderField(const char *aString, size_t aLength);
+
+    /**
+     * This method sets the header value of the previously set header of a request.
+     *
+     * @param[in] aString  A pointer points to body string.
+     * @param[in] aLength  Length of the body string
+     *
+     */
+    void SetHeaderValue(const char *aString, size_t aLength);
+
     /**
      * This method labels the request as complete which means it no longer need to be parsed one more time .
      *
@@ -123,6 +141,14 @@ public:
      */
     std::string GetUrl(void) const;
 
+    /**
+     * This method returns the specified header field for this request.
+     *
+     * @param[in] aHeaderField  A header field.
+     * @returns A string contains the header value of this request.
+     */
+    std::string GetHeaderValue(const std::string aHeaderField) const;
+
     /**
      * This method indicates whether this request is parsed completely.
      *
@@ -131,11 +157,13 @@ public:
     bool IsComplete(void) const;
 
 private:
-    int32_t     mMethod;
-    size_t      mContentLength;
-    std::string mUrl;
-    std::string mBody;
-    bool        mComplete;
+    int32_t                            mMethod;
+    size_t                             mContentLength;
+    std::string                        mUrl;
+    std::string                        mBody;
+    std::string                        mNextHeaderField;
+    std::map<std::string, std::string> mHeaders;
+    bool                               mComplete;
 };
 
 } // namespace rest
diff --git a/src/rest/resource.cpp b/src/rest/resource.cpp
index fdd1171339..a3265825f9 100644
--- a/src/rest/resource.cpp
+++ b/src/rest/resource.cpp
@@ -45,18 +45,21 @@
 #define OT_REST_RESOURCE_PATH_NODE_LEADERDATA "/node/leader-data"
 #define OT_REST_RESOURCE_PATH_NODE_NUMOFROUTER "/node/num-of-router"
 #define OT_REST_RESOURCE_PATH_NODE_EXTPANID "/node/ext-panid"
-#define OT_REST_RESOURCE_PATH_NODE_ACTIVE_DATASET_TLVS "/node/active-dataset-tlvs"
+#define OT_REST_RESOURCE_PATH_NODE_DATASET_ACTIVE "/node/dataset/active"
+#define OT_REST_RESOURCE_PATH_NODE_DATASET_PENDING "/node/dataset/pending"
 #define OT_REST_RESOURCE_PATH_NETWORK "/networks"
 #define OT_REST_RESOURCE_PATH_NETWORK_CURRENT "/networks/current"
 #define OT_REST_RESOURCE_PATH_NETWORK_CURRENT_COMMISSION "/networks/commission"
 #define OT_REST_RESOURCE_PATH_NETWORK_CURRENT_PREFIX "/networks/current/prefix"
 
 #define OT_REST_HTTP_STATUS_200 "200 OK"
-#define OT_REST_HTTP_STATUS_202 "202 Accepted"
+#define OT_REST_HTTP_STATUS_201 "201 Created"
+#define OT_REST_HTTP_STATUS_204 "204 No Content"
 #define OT_REST_HTTP_STATUS_400 "400 Bad Request"
 #define OT_REST_HTTP_STATUS_404 "404 Not Found"
 #define OT_REST_HTTP_STATUS_405 "405 Method Not Allowed"
 #define OT_REST_HTTP_STATUS_408 "408 Request Timeout"
+#define OT_REST_HTTP_STATUS_409 "409 Conflict"
 #define OT_REST_HTTP_STATUS_500 "500 Internal Server Error"
 
 using std::chrono::duration_cast;
@@ -90,8 +93,11 @@ static std::string GetHttpStatus(HttpStatusCode aErrorCode)
     case HttpStatusCode::kStatusOk:
         httpStatus = OT_REST_HTTP_STATUS_200;
         break;
-    case HttpStatusCode::kStatusAccepted:
-        httpStatus = OT_REST_HTTP_STATUS_202;
+    case HttpStatusCode::kStatusCreated:
+        httpStatus = OT_REST_HTTP_STATUS_201;
+        break;
+    case HttpStatusCode::kStatusNoContent:
+        httpStatus = OT_REST_HTTP_STATUS_204;
         break;
     case HttpStatusCode::kStatusBadRequest:
         httpStatus = OT_REST_HTTP_STATUS_400;
@@ -105,6 +111,9 @@ static std::string GetHttpStatus(HttpStatusCode aErrorCode)
     case HttpStatusCode::kStatusRequestTimeout:
         httpStatus = OT_REST_HTTP_STATUS_408;
         break;
+    case HttpStatusCode::kStatusConflict:
+        httpStatus = OT_REST_HTTP_STATUS_409;
+        break;
     case HttpStatusCode::kStatusInternalServerError:
         httpStatus = OT_REST_HTTP_STATUS_500;
         break;
@@ -127,8 +136,9 @@ Resource::Resource(ControllerOpenThread *aNcp)
     mResourceMap.emplace(OT_REST_RESOURCE_PATH_NODE_LEADERDATA, &Resource::LeaderData);
     mResourceMap.emplace(OT_REST_RESOURCE_PATH_NODE_NUMOFROUTER, &Resource::NumOfRoute);
     mResourceMap.emplace(OT_REST_RESOURCE_PATH_NODE_EXTPANID, &Resource::ExtendedPanId);
-    mResourceMap.emplace(OT_REST_RESOURCE_PATH_NODE_ACTIVE_DATASET_TLVS, &Resource::ActiveDatasetTlvs);
     mResourceMap.emplace(OT_REST_RESOURCE_PATH_NODE_RLOC, &Resource::Rloc);
+    mResourceMap.emplace(OT_REST_RESOURCE_PATH_NODE_DATASET_ACTIVE, &Resource::DatasetActive);
+    mResourceMap.emplace(OT_REST_RESOURCE_PATH_NODE_DATASET_PENDING, &Resource::DatasetPending);
 
     // Resource callback handler
     mResourceCallbackMap.emplace(OT_REST_RESOURCE_PATH_DIAGNOETIC, &Resource::HandleDiagnosticCallback);
@@ -499,68 +509,164 @@ void Resource::Rloc(const Request &aRequest, Response &aResponse) const
     }
 }
 
-void Resource::GetActiveDatasetTlvs(Response &aResponse) const
+void Resource::GetDataset(DatasetType aDatasetType, const Request &aRequest, Response &aResponse) const
 {
-    otOperationalDatasetTlvs datasetTlvs;
-    otError                  error = OT_ERROR_NONE;
+    otbrError                error = OTBR_ERROR_NONE;
+    struct NodeInfo          node;
     std::string              body;
     std::string              errorCode;
+    otOperationalDataset     dataset;
+    otOperationalDatasetTlvs datasetTlvs;
 
-    SuccessOrExit(error = otDatasetGetActiveTlvs(mInstance, &datasetTlvs));
+    if (aRequest.GetHeaderValue(OT_REST_ACCEPT_HEADER) == OT_REST_CONTENT_TYPE_PLAIN)
+    {
+        if (aDatasetType == DatasetType::kActive)
+        {
+            VerifyOrExit(otDatasetGetActiveTlvs(mInstance, &datasetTlvs) == OT_ERROR_NONE,
+                         error = OTBR_ERROR_NOT_FOUND);
+        }
+        else if (aDatasetType == DatasetType::kPending)
+        {
+            VerifyOrExit(otDatasetGetPendingTlvs(mInstance, &datasetTlvs) == OT_ERROR_NONE,
+                         error = OTBR_ERROR_NOT_FOUND);
+        }
 
-    body = Json::Bytes2HexJsonString(datasetTlvs.mTlvs, datasetTlvs.mLength);
+        aResponse.SetContentType(OT_REST_CONTENT_TYPE_PLAIN);
+        body = Utils::Bytes2Hex(datasetTlvs.mTlvs, datasetTlvs.mLength);
+    }
+    else
+    {
+        if (aDatasetType == DatasetType::kActive)
+        {
+            VerifyOrExit(otDatasetGetActive(mInstance, &dataset) == OT_ERROR_NONE, error = OTBR_ERROR_NOT_FOUND);
+            body = Json::ActiveDataset2JsonString(dataset);
+        }
+        else if (aDatasetType == DatasetType::kPending)
+        {
+            VerifyOrExit(otDatasetGetPending(mInstance, &dataset) == OT_ERROR_NONE, error = OTBR_ERROR_NOT_FOUND);
+            body = Json::PendingDataset2JsonString(dataset);
+        }
+    }
 
     aResponse.SetBody(body);
-    errorCode = GetHttpStatus(HttpStatusCode::kStatusOk);
-    aResponse.SetResponsCode(errorCode);
 
 exit:
-    if (error != OT_ERROR_NONE)
+    if (error == OTBR_ERROR_NONE)
+    {
+        errorCode = GetHttpStatus(HttpStatusCode::kStatusOk);
+        aResponse.SetResponsCode(errorCode);
+    }
+    else if (error == OTBR_ERROR_NOT_FOUND)
+    {
+        errorCode = GetHttpStatus(HttpStatusCode::kStatusNoContent);
+        aResponse.SetResponsCode(errorCode);
+    }
+    else
     {
-        otbrLogWarning("Failed to get active dataset: %s", otThreadErrorToString(error));
         ErrorHandler(aResponse, HttpStatusCode::kStatusInternalServerError);
     }
 }
 
-void Resource::SetActiveDatasetTlvs(const Request &aRequest, Response &aResponse) const
+void Resource::SetDataset(DatasetType aDatasetType, const Request &aRequest, Response &aResponse) const
 {
-    int                      ret;
+    otError                  errorOt = OT_ERROR_NONE;
+    otbrError                error   = OTBR_ERROR_NONE;
+    struct NodeInfo          node;
+    std::string              body;
+    std::string              errorCode = GetHttpStatus(HttpStatusCode::kStatusOk);
+    otOperationalDataset     dataset;
     otOperationalDatasetTlvs datasetTlvs;
-    otError                  error = OT_ERROR_NONE;
-    std::string              errorCode;
+    otOperationalDatasetTlvs datasetUpdateTlvs;
+    int                      ret;
+    bool                     isTlv;
 
-    ret = Json::Hex2BytesJsonString(aRequest.GetBody(), datasetTlvs.mTlvs, OT_OPERATIONAL_DATASET_MAX_LENGTH);
-    if (ret < 0)
+    if (aDatasetType == DatasetType::kActive)
     {
-        errorCode = GetHttpStatus(HttpStatusCode::kStatusBadRequest);
-        aResponse.SetResponsCode(errorCode);
-        ExitNow();
+        VerifyOrExit(otThreadGetDeviceRole(mInstance) == OT_DEVICE_ROLE_DISABLED, error = OTBR_ERROR_INVALID_STATE);
+        errorOt = otDatasetGetActiveTlvs(mInstance, &datasetTlvs);
+    }
+    else if (aDatasetType == DatasetType::kPending)
+    {
+        errorOt = otDatasetGetPendingTlvs(mInstance, &datasetTlvs);
     }
-    datasetTlvs.mLength = ret;
 
-    SuccessOrExit(error = otDatasetSetActiveTlvs(mInstance, &datasetTlvs));
+    // Create a new operational dataset if it doesn't exist.
+    if (errorOt == OT_ERROR_NOT_FOUND)
+    {
+        VerifyOrExit(otDatasetCreateNewNetwork(mInstance, &dataset) == OT_ERROR_NONE, error = OTBR_ERROR_REST);
+        VerifyOrExit(otDatasetConvertToTlvs(&dataset, &datasetTlvs) == OT_ERROR_NONE, error = OTBR_ERROR_REST);
+        errorCode = GetHttpStatus(HttpStatusCode::kStatusCreated);
+    }
+
+    isTlv = aRequest.GetHeaderValue(OT_REST_CONTENT_TYPE_HEADER) == OT_REST_CONTENT_TYPE_PLAIN;
+
+    if (isTlv)
+    {
+        ret = Json::Hex2BytesJsonString(aRequest.GetBody(), datasetUpdateTlvs.mTlvs, OT_OPERATIONAL_DATASET_MAX_LENGTH);
+        VerifyOrExit(ret >= 0, error = OTBR_ERROR_INVALID_ARGS);
+        datasetUpdateTlvs.mLength = ret;
+
+        VerifyOrExit(otDatasetParseTlvs(&datasetUpdateTlvs, &dataset) == OT_ERROR_NONE, error = OTBR_ERROR_REST);
+        VerifyOrExit(otDatasetUpdateTlvs(&dataset, &datasetTlvs) == OT_ERROR_NONE, error = OTBR_ERROR_REST);
+    }
+    else
+    {
+        if (aDatasetType == DatasetType::kActive)
+        {
+            VerifyOrExit(Json::JsonActiveDatasetString2Dataset(aRequest.GetBody(), dataset),
+                         error = OTBR_ERROR_INVALID_ARGS);
+        }
+        else if (aDatasetType == DatasetType::kPending)
+        {
+            VerifyOrExit(Json::JsonPendingDatasetString2Dataset(aRequest.GetBody(), dataset),
+                         error = OTBR_ERROR_INVALID_ARGS);
+            VerifyOrExit(dataset.mComponents.mIsDelayPresent, error = OTBR_ERROR_INVALID_ARGS);
+        }
+        VerifyOrExit(otDatasetUpdateTlvs(&dataset, &datasetTlvs) == OT_ERROR_NONE, error = OTBR_ERROR_REST);
+    }
+
+    if (aDatasetType == DatasetType::kActive)
+    {
+        VerifyOrExit(otDatasetSetActiveTlvs(mInstance, &datasetTlvs) == OT_ERROR_NONE, error = OTBR_ERROR_REST);
+    }
+    else if (aDatasetType == DatasetType::kPending)
+    {
+        VerifyOrExit(otDatasetSetPendingTlvs(mInstance, &datasetTlvs) == OT_ERROR_NONE, error = OTBR_ERROR_REST);
+    }
 
-    errorCode = GetHttpStatus(HttpStatusCode::kStatusAccepted);
     aResponse.SetResponsCode(errorCode);
+
 exit:
-    if (error != OT_ERROR_NONE)
+    if (error == OTBR_ERROR_INVALID_ARGS)
+    {
+        ErrorHandler(aResponse, HttpStatusCode::kStatusBadRequest);
+    }
+    else if (error == OTBR_ERROR_INVALID_STATE)
+    {
+        ErrorHandler(aResponse, HttpStatusCode::kStatusConflict);
+    }
+    else if (error != OTBR_ERROR_NONE)
     {
-        otbrLogWarning("Failed to set active dataset: %s", otThreadErrorToString(error));
         ErrorHandler(aResponse, HttpStatusCode::kStatusInternalServerError);
     }
 }
 
-void Resource::ActiveDatasetTlvs(const Request &aRequest, Response &aResponse) const
+void Resource::Dataset(DatasetType aDatasetType, const Request &aRequest, Response &aResponse) const
 {
     std::string errorCode;
 
     switch (aRequest.GetMethod())
     {
     case HttpMethod::kGet:
-        GetActiveDatasetTlvs(aResponse);
+        GetDataset(aDatasetType, aRequest, aResponse);
         break;
     case HttpMethod::kPut:
-        SetActiveDatasetTlvs(aRequest, aResponse);
+        SetDataset(aDatasetType, aRequest, aResponse);
+        break;
+    case HttpMethod::kOptions:
+        errorCode = GetHttpStatus(HttpStatusCode::kStatusOk);
+        aResponse.SetResponsCode(errorCode);
+        aResponse.SetComplete();
         break;
     default:
         ErrorHandler(aResponse, HttpStatusCode::kStatusMethodNotAllowed);
@@ -568,6 +674,16 @@ void Resource::ActiveDatasetTlvs(const Request &aRequest, Response &aResponse) c
     }
 }
 
+void Resource::DatasetActive(const Request &aRequest, Response &aResponse) const
+{
+    Dataset(DatasetType::kActive, aRequest, aResponse);
+}
+
+void Resource::DatasetPending(const Request &aRequest, Response &aResponse) const
+{
+    Dataset(DatasetType::kPending, aRequest, aResponse);
+}
+
 void Resource::DeleteOutDatedDiagnostic(void)
 {
     auto eraseIt = mDiagSet.begin();
diff --git a/src/rest/resource.hpp b/src/rest/resource.hpp
index 7c0d4c2e7d..2d25b7bc58 100644
--- a/src/rest/resource.hpp
+++ b/src/rest/resource.hpp
@@ -39,6 +39,8 @@
 #include <openthread/border_router.h>
 
 #include "ncp/ncp_openthread.hpp"
+#include "openthread/dataset.h"
+#include "openthread/dataset_ftd.h"
 #include "rest/json.hpp"
 #include "rest/request.hpp"
 #include "rest/response.hpp"
@@ -102,6 +104,16 @@ public:
     void ErrorHandler(Response &aResponse, HttpStatusCode aErrorCode) const;
 
 private:
+    /**
+     * This enumeration represents the Dataset type (active or pending).
+     *
+     */
+    enum class DatasetType : uint8_t
+    {
+        kActive,  ///< Active Dataset
+        kPending, ///< Pending Dataset
+    };
+
     typedef void (Resource::*ResourceHandler)(const Request &aRequest, Response &aResponse) const;
     typedef void (Resource::*ResourceCallbackHandler)(const Request &aRequest, Response &aResponse);
     void NodeInfo(const Request &aRequest, Response &aResponse) const;
@@ -113,7 +125,9 @@ private:
     void Rloc16(const Request &aRequest, Response &aResponse) const;
     void ExtendedPanId(const Request &aRequest, Response &aResponse) const;
     void Rloc(const Request &aRequest, Response &aResponse) const;
-    void ActiveDatasetTlvs(const Request &aRequest, Response &aResponse) const;
+    void Dataset(DatasetType aDatasetType, const Request &aRequest, Response &aResponse) const;
+    void DatasetActive(const Request &aRequest, Response &aResponse) const;
+    void DatasetPending(const Request &aRequest, Response &aResponse) const;
     void Diagnostic(const Request &aRequest, Response &aResponse) const;
     void HandleDiagnosticCallback(const Request &aRequest, Response &aResponse);
 
@@ -126,8 +140,8 @@ private:
     void GetDataRloc16(Response &aResponse) const;
     void GetDataExtendedPanId(Response &aResponse) const;
     void GetDataRloc(Response &aResponse) const;
-    void GetActiveDatasetTlvs(Response &aResponse) const;
-    void SetActiveDatasetTlvs(const Request &aRequest, Response &aResponse) const;
+    void GetDataset(DatasetType aDatasetType, const Request &aRequest, Response &aResponse) const;
+    void SetDataset(DatasetType aDatasetType, const Request &aRequest, Response &aResponse) const;
 
     void DeleteOutDatedDiagnostic(void);
     void UpdateDiag(std::string aKey, std::vector<otNetworkDiagTlv> &aDiag);
diff --git a/src/rest/response.cpp b/src/rest/response.cpp
index 2fd536c546..93cbe0b6df 100644
--- a/src/rest/response.cpp
+++ b/src/rest/response.cpp
@@ -30,12 +30,11 @@
 
 #include <stdio.h>
 
-#define OT_REST_RESPONSE_CONTENT_TYPE_JSON "application/json"
 #define OT_REST_RESPONSE_ACCESS_CONTROL_ALLOW_ORIGIN "*"
 #define OT_REST_RESPONSE_ACCESS_CONTROL_ALLOW_HEADERS                                                              \
     "Access-Control-Allow-Headers, Origin,Accept, X-Requested-With, Content-Type, Access-Control-Request-Method, " \
     "Access-Control-Request-Headers"
-#define OT_REST_RESPONSE_ACCESS_CONTROL_ALLOW_METHOD "GET"
+#define OT_REST_RESPONSE_ACCESS_CONTROL_ALLOW_METHOD "GET, OPTIONS, PUT"
 #define OT_REST_RESPONSE_CONNECTION "close"
 
 namespace otbr {
@@ -49,7 +48,7 @@ Response::Response(void)
     mProtocol = "HTTP/1.1";
 
     // Pre-defined headers
-    mHeaders["Content-Type"]                 = OT_REST_RESPONSE_CONTENT_TYPE_JSON;
+    mHeaders[OT_REST_CONTENT_TYPE_HEADER]    = OT_REST_CONTENT_TYPE_JSON;
     mHeaders["Access-Control-Allow-Origin"]  = OT_REST_RESPONSE_ACCESS_CONTROL_ALLOW_ORIGIN;
     mHeaders["Access-Control-Allow-Methods"] = OT_REST_RESPONSE_ACCESS_CONTROL_ALLOW_METHOD;
     mHeaders["Access-Control-Allow-Headers"] = OT_REST_RESPONSE_ACCESS_CONTROL_ALLOW_HEADERS;
@@ -81,6 +80,11 @@ void Response::SetResponsCode(std::string &aCode)
     mCode = aCode;
 }
 
+void Response::SetContentType(const std::string &aContentType)
+{
+    mHeaders[OT_REST_CONTENT_TYPE_HEADER] = aContentType;
+}
+
 void Response::SetCallback(void)
 {
     mCallback = true;
diff --git a/src/rest/response.hpp b/src/rest/response.hpp
index 8ae24ffe30..a7cb73e372 100644
--- a/src/rest/response.hpp
+++ b/src/rest/response.hpp
@@ -86,6 +86,14 @@ public:
      */
     void SetResponsCode(std::string &aCode);
 
+    /**
+     * This method sets the content type.
+     *
+     * @param[in] aCode  A string representing response content type such as text/plain.
+     *
+     */
+    void SetContentType(const std::string &aContentType);
+
     /**
      * This method labels the response as need callback.
      *
diff --git a/src/rest/types.hpp b/src/rest/types.hpp
index addc7d2cbb..8216a978d7 100644
--- a/src/rest/types.hpp
+++ b/src/rest/types.hpp
@@ -40,6 +40,12 @@
 
 #include "openthread/netdiag.h"
 
+#define OT_REST_ACCEPT_HEADER "Accept"
+#define OT_REST_CONTENT_TYPE_HEADER "Content-Type"
+
+#define OT_REST_CONTENT_TYPE_JSON "application/json"
+#define OT_REST_CONTENT_TYPE_PLAIN "text/plain"
+
 using std::chrono::steady_clock;
 
 namespace otbr {
@@ -59,11 +65,13 @@ enum class HttpMethod : std::uint8_t
 enum class HttpStatusCode : std::uint16_t
 {
     kStatusOk                  = 200,
-    kStatusAccepted            = 202,
+    kStatusCreated             = 201,
+    kStatusNoContent           = 204,
     kStatusBadRequest          = 400,
     kStatusResourceNotFound    = 404,
     kStatusMethodNotAllowed    = 405,
     kStatusRequestTimeout      = 408,
+    kStatusConflict            = 409,
     kStatusInternalServerError = 500,
 };
 
diff --git a/src/utils/hex.cpp b/src/utils/hex.cpp
index ad4eba9266..45da74e96f 100644
--- a/src/utils/hex.cpp
+++ b/src/utils/hex.cpp
@@ -96,34 +96,48 @@ size_t Bytes2Hex(const uint8_t *aBytes, const uint16_t aBytesLength, char *aHex)
 {
     char byteHex[3];
 
-    std::string hexString;
-    uint8_t     cur[aBytesLength];
-
-    memcpy(cur, aBytes, aBytesLength);
+    // Make sure strcat appends at the beginning of the output buffer even
+    // if uninitialized.
+    aHex[0] = '\0';
 
     for (int i = 0; i < aBytesLength; i++)
     {
-        sprintf(byteHex, "%02X", cur[i]);
-        hexString += byteHex;
+        snprintf(byteHex, sizeof(byteHex), "%02X", aBytes[i]);
+        strcat(aHex, byteHex);
     }
-    strcpy(aHex, hexString.c_str());
+
     return strlen(aHex);
 }
 
+std::string Bytes2Hex(const uint8_t *aBytes, const uint16_t aBytesLength)
+{
+    char        hex[2 * aBytesLength + 1];
+    std::string s;
+    size_t      len;
+
+    len = Bytes2Hex(aBytes, aBytesLength, hex);
+    s   = std::string(hex, len);
+
+    return s;
+}
+
 size_t Long2Hex(const uint64_t aLong, char *aHex)
 {
-    std::string hexString;
-    char        byteHex[3];
-    uint64_t    longValue = aLong;
+    char     byteHex[3];
+    uint64_t longValue = aLong;
+
+    // Make sure strcat appends at the beginning of the output buffer even
+    // if uninitialized.
+    aHex[0] = '\0';
 
     for (uint8_t i = 0; i < sizeof(uint64_t); i++)
     {
         uint8_t byte = longValue & 0xff;
-        sprintf(byteHex, "%02X", byte);
-        hexString += byteHex;
+        snprintf(byteHex, sizeof(byteHex), "%02X", byte);
+        strcat(aHex, byteHex);
         longValue = longValue >> 8;
     }
-    strcpy(aHex, hexString.c_str());
+
     return strlen(aHex);
 }
 
diff --git a/src/utils/hex.hpp b/src/utils/hex.hpp
index 0aa4b23946..49ba37d561 100644
--- a/src/utils/hex.hpp
+++ b/src/utils/hex.hpp
@@ -36,6 +36,8 @@
 
 #include "openthread-br/config.h"
 
+#include <string>
+
 #include <stddef.h>
 #include <stdint.h>
 
@@ -43,10 +45,48 @@ namespace otbr {
 
 namespace Utils {
 
+/**
+ * @brief Converts a hexadecimal string to a byte array.
+ *
+ * @param hexString A pointer to the hexadecimal string to be converted.
+ * @param bytes A pointer to an array to store the resulting byte values.
+ * @param maxBytesLength The maximum number of bytes that can be stored in the `bytes` array.
+ *
+ * @return The number of bytes stored in the `bytes` array, or -1 if an error occurred.
+ */
 int Hex2Bytes(const char *aHex, uint8_t *aBytes, uint16_t aBytesLength);
 
+/**
+ * @brief Converts a byte array to a hexadecimal string.
+ *
+ * @param[in]  aBytes A pointer to the byte array to be converted.
+ * @param[in]  aBytesLength The length of the byte array.
+ * @param[out] aHex A character array to store the resulting hexadecimal string.
+ *                  Must be at least 2 * @param aBytesLength + 1 long.
+ *
+ * @return The length of the resulting hexadecimal string.
+ */
 size_t Bytes2Hex(const uint8_t *aBytes, const uint16_t aBytesLength, char *aHex);
 
+/**
+ * @brief Converts a byte array to a hexadecimal string.
+ *
+ * @param[in]  aBytes A pointer to the byte array to be converted.
+ * @param[in]  aBytesLength The length of the byte array.
+ *
+ * @return The hexadecimal string.
+ */
+std::string Bytes2Hex(const uint8_t *aBytes, const uint16_t aBytesLength);
+
+/**
+ * @brief Converts a 64-bit integer to a hexadecimal string.
+ *
+ * @param[in]  aLong The 64-bit integer to be converted.
+ * @param[out] aHex A character array to store the resulting hexadecimal string.
+ *                  Must be at least 17 bytes long.
+ *
+ * @return The length of the resulting hexadecimal string.
+ */
 size_t Long2Hex(const uint64_t aLong, char *aHex);
 
 } // namespace Utils
-- 
2.40.1

