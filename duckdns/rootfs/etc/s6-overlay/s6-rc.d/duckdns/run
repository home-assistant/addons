#!/usr/bin/with-contenv bashio
# vim: ft=bash
# shellcheck shell=bash

CERT_DIR=/data/letsencrypt
WORK_DIR=/data/workdir

# Let's encrypt
LE_UPDATE="0"

# DuckDNS
if bashio::config.has_value "ipv4"; then IPV4=$(bashio::config 'ipv4'); else IPV4=""; fi
if bashio::config.has_value "ipv6"; then IPV6=$(bashio::config 'ipv6'); else IPV6=""; fi
TOKEN=$(bashio::config 'token')
DOMAINS=$(bashio::config 'domains | join(",")')
WAIT_TIME=$(bashio::config 'seconds')
ALGO=$(bashio::config 'lets_encrypt.algo')

# Function that performs a renew
function le_renew() {
    local domain_args=()
    local domains=''
    local aliases=()
	local domainsAndAliases=()

    domains=$(bashio::config 'domains')

    # Prepare domain for Let's Encrypt
	
	# Get a list of aliases against domains first from the options file
    for domain in ${domains}; do
        for alias in $(jq --raw-output --exit-status "[.aliases[]|{(.alias):.domain}]|add.\"${domain}\" | select(. != null)" /data/options.json) ; do
            aliases+=("${alias}")
        done
    done

	readarray -t domainsarray <<< "$domains" # line-separated list of domains into an array
    bashio::log.info "Renew certificate for domains: $(echo -n "${domainsarray[@]}") and aliases: $(echo -n "${aliases[@]}")"
	
	# Combine domains and aliases into one array
	domainsAndAliases=("${domainsarray[@]}" "${aliases[@]}")
	
	# Associative Array is used to filter the combined array to unique values
	declare -A unique_map
	for element in "${domainsAndAliases[@]}"; do
		unique_map["$element"]=""
	done
	domainsAndAliases=("${!unique_map[@]}")
	
	# The Associative Array reverses the ordering. Un-reverse it (mostly for display purposes, domains will be renewed in this order)
	reversed_array=()
	for (( i=${#domainsAndAliases[@]}-1; i>=0; i-- )); do
		reversed_array+=("${domainsAndAliases[i]}")
	done
	domainsAndAliases=("${reversed_array[@]}")
	unset reversed_array
	
	# Actually do the renewals below

    for domain in "${domainsAndAliases[@]}"; do
		domain_args+=("--domain" "${domain}")
		
		# DuckDNS does not support more than a single TXT record, so, process each domain or alias separately and combine later
		dehydrated --cron --algo "${ALGO}" --hook /root/hooks.sh --challenge dns-01 --domain "${domain}" --out "${CERT_DIR}" --config "${WORK_DIR}/config" || true
    done
	
	# This final stage will combine everything into a single cert with SANs for the aliases
	bashio::log.info "Final pass to combine individual certificates"
	dehydrated --cron --algo "${ALGO}" --hook /root/hooks.sh --challenge dns-01 "${domain_args[@]}" --out "${CERT_DIR}" --config "${WORK_DIR}/config" || true

    LE_UPDATE="$(date +%s)"
}

# Register/generate certificate if terms accepted
if bashio::config.true 'lets_encrypt.accept_terms'; then
    # Init folder structs
    mkdir -p "${CERT_DIR}"
    mkdir -p "${WORK_DIR}"

    # Clean up possible stale lock file
    if [ -e "${WORK_DIR}/lock" ]; then
        rm -f "${WORK_DIR}/lock"
        bashio::log.warning "Reset dehydrated lock file"
    fi

    # Generate new certs
    if [ ! -d "${CERT_DIR}/live" ]; then
        # Create empty dehydrated config file so that this dir will be used for storage
        touch "${WORK_DIR}/config"

        dehydrated --register --accept-terms --config "${WORK_DIR}/config"
    fi
fi

# Run duckdns
bashio::log.info "Starting DuckDNS..."
while true; do
    [[ ${IPV4} != *:/* ]] && ipv4=${IPV4} || ipv4=$(curl -s -m 10 "${IPV4}")
    [[ ${IPV6} != *:/* ]] && ipv6=${IPV6} || ipv6=$(curl -s -m 10 "${IPV6}")

    # Get IPv6-address from host interface
    if [[ -n "$IPV6" && ${ipv6} != *:* ]]; then
        ipv6=
        bashio::cache.flush_all
        for addr in $(bashio::network.ipv6_address "$IPV6"); do
	    # Skip non-global addresses
	    if [[ ${addr} != fe80:* && ${addr} != fc* && ${addr} != fd* ]]; then
              ipv6=${addr%/*}
              break
            fi
        done
    fi
	
	# Sanitise the DOMAINS, filtering out duplicates, subdomains and wildcard aliases and retaining just the instances of my-domain.duckdns.org	
	duckdnsDomains=$(echo "$DOMAINS" | grep -Eo '[^ .>,]+\.duckdns\.org' | sort -u | paste -sd,)

    if [[ ${ipv6} == *:* ]]; then
        if answer="$(curl -s "https://www.duckdns.org/update?domains=${duckdnsDomains}&token=${TOKEN}&ipv6=${ipv6}&verbose=true")" && [ "${answer}" != 'KO' ]; then
            if [[ "${answer}" == *NOCHANGE* ]]; then
   		bashio::log.debug "${answer}"
	    else
		bashio::log.info "${answer}"
      	    fi
        else
            bashio::log.warning "${answer}"
        fi
    fi

    if [[ -z ${ipv4} || ${ipv4} == *.* ]]; then
        if answer="$(curl -s "https://www.duckdns.org/update?domains=${duckdnsDomains}&token=${TOKEN}&ip=${ipv4}&verbose=true")" && [ "${answer}" != 'KO' ]; then
            if [[ "${answer}" == *NOCHANGE* ]]; then
   		bashio::log.debug "${answer}"
	    else
		bashio::log.info "${answer}"
      	    fi
        else
            bashio::log.warning "${answer}"
        fi
    fi

    now="$(date +%s)"
    if bashio::config.true 'lets_encrypt.accept_terms' && [ $((now - LE_UPDATE)) -ge 43200 ]; then
        le_renew
    fi

    sleep "${WAIT_TIME}"
done
